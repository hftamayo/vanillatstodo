name: "Destroy Infrastructure"

"on":
  workflow_dispatch:
    inputs:
      confirmation:
        description: "Type 'destroy' to confirm"
        required: true
        type: string

permissions:
  contents: read
  id-token: write

env:
  CLUSTER_NAME: "vanillatstodo-cluster"
  BUCKET_NAME: "vanillatstodo-terraform-state"
  AWS_REGION: "us-east-2"
  TF_VERSION: "1.10.0"
  PROJECT_NAME: "vanillatstodo"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  destroy:
    timeout-minutes: 30
    name: "Destroy Infrastructure"
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirmation == 'destroy' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Destroy EKS Resources
        id: eks_cleanup
        run: |
          # Check if cluster exists first
          echo "üîç Checking if EKS cluster exists..."
          if aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} >/dev/null 2>&1; then
            echo "‚úÖ Found EKS cluster: ${{ env.CLUSTER_NAME }}"

            # Add required EKS permissions
            aws iam attach-role-policy \
              --role-name vanillatstodo-deployer \
              --policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy || \
              echo "‚ö†Ô∏è Could not attach EKS policy - continuing anyway"

            echo "üîç Checking for EKS node groups..."
            NODE_GROUPS=$(aws eks list-nodegroups --cluster-name ${{ env.CLUSTER_NAME }} --query 'nodegroups[*]' --output text || echo "")

            if [ ! -z "$NODE_GROUPS" ]; then
              echo "Found node groups: $NODE_GROUPS"
              for ng in $NODE_GROUPS; do
                echo "üóëÔ∏è Deleting node group: $ng"
                aws eks delete-nodegroup --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name $ng
                echo "‚è≥ Waiting for node group deletion..."
                aws eks wait nodegroup-deleted --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name $ng
              done
            fi

            echo "üóëÔ∏è Deleting EKS cluster..."
            if aws eks delete-cluster --name ${{ env.CLUSTER_NAME }}; then
              echo "EKS_STATUS=‚úÖ" >> $GITHUB_ENV
              aws eks wait cluster-deleted --name ${{ env.CLUSTER_NAME }}
            else
              echo "EKS_STATUS=‚ùå" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è EKS cluster does not exist, skipping..."
            echo "EKS_STATUS=‚úÖ" >> $GITHUB_ENV
          fi

      - name: Clean Up CloudWatch Resources
        id: cloudwatch_cleanup
        run: |
          echo "üîç Finding CloudWatch resources..."

          # Delete CloudWatch Dashboard
          echo "üîç Finding CloudWatch Dashboards..."
          DASHBOARD_NAME="staging-vanillatstodo-cluster-dashboard"
          aws cloudwatch delete-dashboards \
            --dashboard-names "$DASHBOARD_NAME" || true

          # Delete CloudWatch Alarms
          echo "üîç Finding CloudWatch Alarms..."
          aws cloudwatch describe-alarms \
            --alarm-name-prefix "staging-vanillatstodo-cluster" \
            --query 'MetricAlarms[*].AlarmName' \
            --output text | while read -r alarm; do
            if [ ! -z "$alarm" ]; then
              echo "üóëÔ∏è Deleting alarm: $alarm"
              aws cloudwatch delete-alarms --alarm-names "$alarm"
            fi
          done

          # Delete CloudWatch Log Groups
          echo "üîç Finding CloudWatch Log Groups..."
          aws logs describe-log-groups \
            --log-group-name-prefix "/aws/eks/vanillatstodo-cluster" \
            --query 'logGroups[*].logGroupName' \
            --output text | while read -r log_group; do
            if [ ! -z "$log_group" ]; then
              echo "üóëÔ∏è Deleting log group: $log_group"
              aws logs delete-log-group --log-group-name "$log_group"
            fi
          done

          echo "CLOUDWATCH_STATUS=‚úÖ" >> $GITHUB_ENV

      - name: Clean Up Network Resources
        id: network_cleanup
        run: |
          CLEANUP_FAILED=0

          echo "üîç Finding VPC with vanillatstodo tag..."
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=*vanillatstodo*" \
            --query 'Vpcs[0].VpcId' \
            --output text)

          if [ "$VPC_ID" != "None" ] && [ ! -z "$VPC_ID" ]; then
            # Debug VPC Dependencies
            echo "üìã Checking VPC dependencies..."
            echo "VPC Endpoints:"
            aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'VpcEndpoints[*].[VpcEndpointId,State]' \
              --output table

            echo "NAT Gateways:"
            aws ec2 describe-nat-gateways \
              --filter "Name=vpc-id,Values=$VPC_ID" \
              --query 'NatGateways[*].[NatGatewayId,State]' \
              --output table

            # 1. VPC Endpoints
            echo "üóëÔ∏è Cleaning up VPC Endpoints..."
            ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'VpcEndpoints[*].VpcEndpointId' \
              --output text)
            
            for endpoint in $ENDPOINTS; do
              echo "   Deleting endpoint: $endpoint"
              if ! aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $endpoint; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete endpoint: $endpoint"
              fi
              sleep 5
            done

            # 2. NAT Gateways
            echo "üóëÔ∏è Cleaning up NAT Gateways..."
            NAT_IDS=$(aws ec2 describe-nat-gateways \
              --filter "Name=vpc-id,Values=$VPC_ID" \
              --query 'NatGateways[*].NatGatewayId' \
              --output text)
            
            for nat in $NAT_IDS; do
              echo "   Deleting NAT Gateway: $nat"
              if ! aws ec2 delete-nat-gateway --nat-gateway-id $nat; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete NAT Gateway: $nat"
              fi
            done
            
            echo "‚è≥ Waiting for NAT Gateways to be deleted..."
            sleep 30

            # 3. Network Interfaces
            echo "üóëÔ∏è Cleaning up Network Interfaces..."
            ENI_IDS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].NetworkInterfaceId' \
              --output text)
            
            for eni in $ENI_IDS; do
              echo "   Deleting Network Interface: $eni"
              if ! aws ec2 delete-network-interface --network-interface-id $eni; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete Network Interface: $eni"
              fi
            done

            # 4. Security Groups (except default)
            echo "üóëÔ∏è Cleaning up Security Groups..."
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text)
            
            for sg in $SG_IDS; do
              echo "   Deleting Security Group: $sg"
              if ! aws ec2 delete-security-group --group-id $sg; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete Security Group: $sg"
              fi
            done

            # 5. Route Tables (non-main)
            echo "üóëÔ∏è Cleaning up Route Tables..."
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text)
            
            for rt in $RT_IDS; do
              ASSOC_IDS=$(aws ec2 describe-route-tables \
                --route-table-id $rt \
                --query 'RouteTables[0].Associations[*].RouteTableAssociationId' \
                --output text)
              
              for assoc in $ASSOC_IDS; do
                echo "   Disassociating route table: $assoc"
                if ! aws ec2 disassociate-route-table --association-id $assoc; then
                  CLEANUP_FAILED=1
                  echo "‚ö†Ô∏è Failed to disassociate route table: $assoc"
                fi
              done
              
              echo "   Deleting route table: $rt"
              if ! aws ec2 delete-route-table --route-table-id $rt; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete route table: $rt"
              fi
            done

            # 6. Network ACLs (non-default)
            echo "üóëÔ∏è Cleaning up Network ACLs..."
            NACL_IDS=$(aws ec2 describe-network-acls \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkAcls[?!IsDefault].NetworkAclId' \
              --output text)
            
            for nacl in $NACL_IDS; do
              echo "   Deleting Network ACL: $nacl"
              if ! aws ec2 delete-network-acl --network-acl-id $nacl; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete Network ACL: $nacl"
              fi
            done

            # 7. Subnets
            echo "üóëÔ∏è Cleaning up Subnets..."
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text)
            
            for subnet in $SUBNET_IDS; do
              echo "   Deleting subnet: $subnet"
              if ! aws ec2 delete-subnet --subnet-id $subnet; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to delete subnet: $subnet"
              fi
            done

            # 8. Internet Gateway
            echo "üóëÔ∏è Cleaning up Internet Gateway..."
            IGW_ID=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[*].InternetGatewayId' \
              --output text)
            
            if [ ! -z "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
              echo "   Detaching and deleting IGW: $IGW_ID"
              if ! aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID || \
                 ! aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID; then
                CLEANUP_FAILED=1
                echo "‚ö†Ô∏è Failed to cleanup IGW: $IGW_ID"
              fi
            fi

            # 9. Finally Delete VPC
            echo "üóëÔ∏è Deleting VPC: $VPC_ID"
            if ! aws ec2 delete-vpc --vpc-id $VPC_ID; then
              CLEANUP_FAILED=1
              echo "‚ö†Ô∏è Failed to delete VPC: $VPC_ID"
            fi

            # Set final status
            if [ $CLEANUP_FAILED -eq 0 ]; then
              echo "‚úÖ Network cleanup completed successfully"
              echo "NETWORK_STATUS=‚úÖ" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è Network cleanup completed with errors"
              echo "NETWORK_STATUS=‚ùå" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è No VPC found matching the filter"
            echo "NETWORK_STATUS=‚úÖ" >> $GITHUB_ENV
          fi

      - name: Clean Up S3 Resources
        id: s3_cleanup
        run: |
          echo "üîç Checking S3 bucket: ${{ env.BUCKET_NAME }}"
          if aws s3api head-bucket --bucket ${{ env.BUCKET_NAME }} 2>/dev/null; then
            echo "üì¶ Found bucket: ${{ env.BUCKET_NAME }}"
            
            # List and delete all versions
            echo "üóëÔ∏è Deleting all object versions..."
            aws s3api list-object-versions \
              --bucket ${{ env.BUCKET_NAME }} \
              --output json | \
            jq -r '.Versions[]? | "\(.Key)\t\(.VersionId)"' | \
            while IFS=$'\t' read -r key version; do
              echo "Deleting key: $key version: $version"
              aws s3api delete-object \
                --bucket ${{ env.BUCKET_NAME }} \
                --key "$key" \
                --version-id "$version"
            done

            # Delete delete markers
            echo "üóëÔ∏è Cleaning up delete markers..."
            aws s3api list-object-versions \
              --bucket ${{ env.BUCKET_NAME }} \
              --output json | \
            jq -r '.DeleteMarkers[]? | "\(.Key)\t\(.VersionId)"' | \
            while IFS=$'\t' read -r key version; do
              echo "Removing delete marker: $key version: $version"
              aws s3api delete-object \
                --bucket ${{ env.BUCKET_NAME }} \
                --key "$key" \
                --version-id "$version"
            done

            # Final verification and bucket deletion
            echo "üîç Verifying bucket is empty..."
            sleep 5
            
            REMAINING=$(aws s3api list-object-versions \
              --bucket ${{ env.BUCKET_NAME }} \
              --output json | \
              jq '.Versions + .DeleteMarkers | length')

            if [ "$REMAINING" = "0" ]; then
              echo "üóëÔ∏è Deleting empty bucket..."
              if aws s3api delete-bucket --bucket ${{ env.BUCKET_NAME }}; then
                echo "‚úÖ S3 bucket deleted successfully"
                echo "S3_STATUS=‚úÖ" >> $GITHUB_ENV
              else
                echo "‚ùå Failed to delete bucket"
                echo "S3_STATUS=‚ùå" >> $GITHUB_ENV
              fi
            else
              echo "‚ö†Ô∏è Bucket still contains objects"
              echo "S3_STATUS=‚ùå" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è Bucket not found or already deleted"
            echo "S3_STATUS=‚úÖ" >> $GITHUB_ENV
          fi

      - name: Summarize Cleanup Status
        if: always()
        run: |
          echo "### Cleanup Summary üßπ" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "| -------- | ------ | ------- |" >> $GITHUB_STEP_SUMMARY
          echo "| EKS Cluster | ${EKS_STATUS:-‚ùå} | Version: 1.31 |" >> $GITHUB_STEP_SUMMARY
          echo "| CloudWatch | ${CLOUDWATCH_STATUS:-‚ùå} | Monitoring |" >> $GITHUB_STEP_SUMMARY

          # Network Resources Detail
          echo "| Network - VPC Endpoints | ${NETWORK_ENDPOINTS_STATUS:-‚ùå} | Interface Endpoints |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NAT & EIP | ${NETWORK_NAT_STATUS:-‚ùå} | NAT Gateways |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Route Tables | ${NETWORK_ROUTE_STATUS:-‚ùå} | Routing |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NACLs | ${NETWORK_NACL_STATUS:-‚ùå} | Network ACLs |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Subnets | ${NETWORK_SUBNET_STATUS:-‚ùå} | Subnet Resources |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - IGW | ${NETWORK_IGW_STATUS:-‚ùå} | Internet Gateway |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Overall | ${NETWORK_STATUS:-‚ùå} | Network Stack |" >> $GITHUB_STEP_SUMMARY

          echo "| S3 State | ${S3_STATUS:-‚ùå} | Terraform State |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform Version: \`${TF_VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Region: \`${AWS_REGION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Project: \`${PROJECT_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Timestamp: \`$(date -u '+%Y-%m-%d %H:%M:%S UTC')\`" >> $GITHUB_STEP_SUMMARY
