name: "Destroy Infrastructure"

"on":
  workflow_dispatch:
    inputs:
      confirmation:
        description: "Type 'destroy' to confirm"
        required: true
        type: string

permissions:
  contents: read
  id-token: write

env:
  CLUSTER_NAME: "vanillatstodo-cluster"
  BUCKET_NAME: "vanillatstodo-terraform-state"
  AWS_REGION: "us-east-2"
  TF_VERSION: "1.10.0"
  PROJECT_NAME: "vanillatstodo"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  destroy:
    timeout-minutes: 30
    name: "Destroy Infrastructure"
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirmation == 'destroy' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Destroy EKS Resources
        id: eks_cleanup
        run: |
          # Check if cluster exists first
          echo "üîç Checking if EKS cluster exists..."
          if aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} >/dev/null 2>&1; then
            echo "‚úÖ Found EKS cluster: ${{ env.CLUSTER_NAME }}"

            # Add required EKS permissions
            aws iam attach-role-policy \
              --role-name vanillatstodo-deployer \
              --policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy || \
              echo "‚ö†Ô∏è Could not attach EKS policy - continuing anyway"

            echo "üîç Checking for EKS node groups..."
            NODE_GROUPS=$(aws eks list-nodegroups --cluster-name ${{ env.CLUSTER_NAME }} --query 'nodegroups[*]' --output text || echo "")

            if [ ! -z "$NODE_GROUPS" ]; then
              echo "Found node groups: $NODE_GROUPS"
              for ng in $NODE_GROUPS; do
                echo "üóëÔ∏è Deleting node group: $ng"
                aws eks delete-nodegroup --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name $ng
                echo "‚è≥ Waiting for node group deletion..."
                aws eks wait nodegroup-deleted --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name $ng
              done
            fi

            echo "üóëÔ∏è Deleting EKS cluster..."
            if aws eks delete-cluster --name ${{ env.CLUSTER_NAME }}; then
              echo "EKS_STATUS=‚úÖ" >> $GITHUB_ENV
              aws eks wait cluster-deleted --name ${{ env.CLUSTER_NAME }}
            else
              echo "EKS_STATUS=‚ùå" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è EKS cluster does not exist, skipping..."
            echo "EKS_STATUS=‚úÖ" >> $GITHUB_ENV
          fi

      - name: Clean Up CloudWatch Resources
        id: cloudwatch_cleanup
        run: |
          echo "üîç Finding CloudWatch resources..."

          # Delete CloudWatch Dashboard
          echo "üîç Finding CloudWatch Dashboards..."
          DASHBOARD_NAME="staging-vanillatstodo-cluster-dashboard"
          aws cloudwatch delete-dashboards \
            --dashboard-names "$DASHBOARD_NAME" || true

          # Delete CloudWatch Alarms
          echo "üîç Finding CloudWatch Alarms..."
          aws cloudwatch describe-alarms \
            --alarm-name-prefix "staging-vanillatstodo-cluster" \
            --query 'MetricAlarms[*].AlarmName' \
            --output text | while read -r alarm; do
            if [ ! -z "$alarm" ]; then
              echo "üóëÔ∏è Deleting alarm: $alarm"
              aws cloudwatch delete-alarms --alarm-names "$alarm"
            fi
          done

          # Delete CloudWatch Log Groups
          echo "üîç Finding CloudWatch Log Groups..."
          aws logs describe-log-groups \
            --log-group-name-prefix "/aws/eks/vanillatstodo-cluster" \
            --query 'logGroups[*].logGroupName' \
            --output text | while read -r log_group; do
            if [ ! -z "$log_group" ]; then
              echo "üóëÔ∏è Deleting log group: $log_group"
              aws logs delete-log-group --log-group-name "$log_group"
            fi
          done

          echo "CLOUDWATCH_STATUS=‚úÖ" >> $GITHUB_ENV

      - name: Clean Up Network Resources
        id: network_cleanup
        run: |
          # Initialize counters and status tracking
          declare -A CLEANED_COUNT=(
            ["ENDPOINTS"]=0
            ["NAT"]=0
            ["INTERFACES"]=0
            ["SECURITY_GROUPS"]=0
            ["ROUTE_TABLES"]=0
            ["NACLS"]=0
            ["SUBNETS"]=0
            ["IGW"]=0
            ["VPC"]=0
          )

          declare -A TOTAL_COUNT=(
            ["ENDPOINTS"]=0
            ["NAT"]=0
            ["INTERFACES"]=0
            ["SECURITY_GROUPS"]=0
            ["ROUTE_TABLES"]=0
            ["NACLS"]=0
            ["SUBNETS"]=0
            ["IGW"]=0
            ["VPC"]=0
          )

          echo "üîç Finding all VPCs with vanillatstodo tag..."
          VPC_IDS=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=*vanillatstodo*" \
            --query 'Vpcs[*].VpcId' \
            --output text)

          for VPC_ID in $VPC_IDS; do
            ((TOTAL_COUNT["VPC"]++))
            echo "üîÑ Processing VPC: $VPC_ID"

            # 1. VPC Endpoints
            echo "üóëÔ∏è Cleaning up VPC Endpoints..."
            ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'VpcEndpoints[*].VpcEndpointId' \
              --output text)
            
            for endpoint in $ENDPOINTS; do
              ((TOTAL_COUNT["ENDPOINTS"]++))
              echo "   Deleting endpoint: $endpoint"
              if aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $endpoint; then
                ((CLEANED_COUNT["ENDPOINTS"]++))
              fi
              sleep 5
            done

            # 2. NAT Gateways
            echo "üóëÔ∏è Cleaning up NAT Gateways..."
            NAT_IDS=$(aws ec2 describe-nat-gateways \
              --filter "Name=vpc-id,Values=$VPC_ID" \
              --query 'NatGateways[?State!=`deleted`].NatGatewayId' \
              --output text)
            
            for nat in $NAT_IDS; do
              ((TOTAL_COUNT["NAT"]++))
              echo "   Deleting NAT Gateway: $nat"
              if aws ec2 delete-nat-gateway --nat-gateway-id $nat; then
                ((CLEANED_COUNT["NAT"]++))
              fi
            done

            [ ! -z "$NAT_IDS" ] && sleep 45

            # 3. Network Interfaces
            echo "üóëÔ∏è Cleaning up Network Interfaces..."
            ENI_IDS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].NetworkInterfaceId' \
              --output text)
            
            for eni in $ENI_IDS; do
              ((TOTAL_COUNT["INTERFACES"]++))
              if aws ec2 describe-network-interfaces \
                --network-interface-ids $eni \
                --query 'NetworkInterfaces[0].Status' \
                --output text | grep -q "available"; then
                echo "   Deleting Network Interface: $eni"
                if aws ec2 delete-network-interface --network-interface-id $eni; then
                  ((CLEANED_COUNT["INTERFACES"]++))
                fi
              fi
              sleep 2
            done

            # 4. Security Groups
            echo "üóëÔ∏è Cleaning up Security Groups..."
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text)
            
            for sg in $SG_IDS; do
              ((TOTAL_COUNT["SECURITY_GROUPS"]++))
              echo "   Deleting Security Group: $sg"
              if aws ec2 delete-security-group --group-id $sg; then
                ((CLEANED_COUNT["SECURITY_GROUPS"]++))
              fi
              sleep 2
            done

            # 5. Route Tables
            echo "üóëÔ∏è Cleaning up Route Tables..."
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text)
            
            for rt in $RT_IDS; do
              ((TOTAL_COUNT["ROUTE_TABLES"]++))
              ASSOC_IDS=$(aws ec2 describe-route-tables \
                --route-table-id $rt \
                --query 'RouteTables[0].Associations[*].RouteTableAssociationId' \
                --output text)
              
              for assoc in $ASSOC_IDS; do
                aws ec2 disassociate-route-table --association-id $assoc
              done
              
              if aws ec2 delete-route-table --route-table-id $rt; then
                ((CLEANED_COUNT["ROUTE_TABLES"]++))
              fi
              sleep 2
            done

            # 6. Network ACLs
            echo "üóëÔ∏è Cleaning up Network ACLs..."
            NACL_IDS=$(aws ec2 describe-network-acls \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkAcls[?!IsDefault].NetworkAclId' \
              --output text)
            
            for nacl in $NACL_IDS; do
              ((TOTAL_COUNT["NACLS"]++))
              if aws ec2 delete-network-acl --network-acl-id $nacl; then
                ((CLEANED_COUNT["NACLS"]++))
              fi
              sleep 2
            done

            # 7. Subnets
            echo "üóëÔ∏è Cleaning up Subnets..."
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text)
            
            for subnet in $SUBNET_IDS; do
              ((TOTAL_COUNT["SUBNETS"]++))
              if aws ec2 delete-subnet --subnet-id $subnet; then
                ((CLEANED_COUNT["SUBNETS"]++))
              fi
              sleep 2
            done

            # 8. Internet Gateway
            echo "üóëÔ∏è Cleaning up Internet Gateway..."
            IGW_ID=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[*].InternetGatewayId' \
              --output text)
            
            if [ ! -z "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
              ((TOTAL_COUNT["IGW"]++))
              if aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID && \
                 aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID; then
                ((CLEANED_COUNT["IGW"]++))
              fi
              sleep 2
            fi

            # 9. VPC
            echo "üóëÔ∏è Deleting VPC: $VPC_ID"
            if aws ec2 delete-vpc --vpc-id $VPC_ID; then
              ((CLEANED_COUNT["VPC"]++))
            fi
          done

          # Update GitHub Environment variables with counts and status
          {
            for resource in "${!CLEANED_COUNT[@]}"; do
              echo "${resource}_CLEANED=${CLEANED_COUNT[$resource]}" >> $GITHUB_ENV
              echo "${resource}_TOTAL=${TOTAL_COUNT[$resource]}" >> $GITHUB_ENV
              if [ "${CLEANED_COUNT[$resource]}" -eq "${TOTAL_COUNT[$resource]}" ]; then
                echo "NETWORK_${resource}_STATUS=‚úÖ" >> $GITHUB_ENV
              else
                echo "NETWORK_${resource}_STATUS=‚ùå" >> $GITHUB_ENV
              fi
            done

            # Set overall network status
            if [ "${CLEANED_COUNT[VPC]}" -eq "${TOTAL_COUNT[VPC]}" ]; then
              echo "NETWORK_STATUS=‚úÖ" >> $GITHUB_ENV
            else
              echo "NETWORK_STATUS=‚ùå" >> $GITHUB_ENV
            fi
          }

      - name: Clean Up S3 Resources
        id: s3_cleanup
        run: |
          echo "üîç Checking S3 bucket: ${{ env.BUCKET_NAME }}"
          if aws s3api head-bucket --bucket ${{ env.BUCKET_NAME }} 2>/dev/null; then
            echo "üì¶ Found bucket: ${{ env.BUCKET_NAME }}"
            
            # List and delete all versions
            echo "üóëÔ∏è Deleting all object versions..."
            aws s3api list-object-versions \
              --bucket ${{ env.BUCKET_NAME }} \
              --output json | \
            jq -r '.Versions[]? | "\(.Key)\t\(.VersionId)"' | \
            while IFS=$'\t' read -r key version; do
              echo "Deleting key: $key version: $version"
              aws s3api delete-object \
                --bucket ${{ env.BUCKET_NAME }} \
                --key "$key" \
                --version-id "$version"
            done

            # Delete delete markers
            echo "üóëÔ∏è Cleaning up delete markers..."
            aws s3api list-object-versions \
              --bucket ${{ env.BUCKET_NAME }} \
              --output json | \
            jq -r '.DeleteMarkers[]? | "\(.Key)\t\(.VersionId)"' | \
            while IFS=$'\t' read -r key version; do
              echo "Removing delete marker: $key version: $version"
              aws s3api delete-object \
                --bucket ${{ env.BUCKET_NAME }} \
                --key "$key" \
                --version-id "$version"
            done

            # Final verification and bucket deletion
            echo "üîç Verifying bucket is empty..."
            sleep 5
            
            REMAINING=$(aws s3api list-object-versions \
              --bucket ${{ env.BUCKET_NAME }} \
              --output json | \
              jq '.Versions + .DeleteMarkers | length')

            if [ "$REMAINING" = "0" ]; then
              echo "üóëÔ∏è Deleting empty bucket..."
              if aws s3api delete-bucket --bucket ${{ env.BUCKET_NAME }}; then
                echo "‚úÖ S3 bucket deleted successfully"
                echo "S3_STATUS=‚úÖ" >> $GITHUB_ENV
              else
                echo "‚ùå Failed to delete bucket"
                echo "S3_STATUS=‚ùå" >> $GITHUB_ENV
              fi
            else
              echo "‚ö†Ô∏è Bucket still contains objects"
              echo "S3_STATUS=‚ùå" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è Bucket not found or already deleted"
            echo "S3_STATUS=‚úÖ" >> $GITHUB_ENV
          fi

      - name: Summarize Cleanup Status
        if: always()
        run: |
          echo "### Cleanup Summary üßπ" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "| -------- | ------ | ------- |" >> $GITHUB_STEP_SUMMARY
          echo "| EKS Cluster | ${EKS_STATUS:-‚ùå} | Version: 1.31 |" >> $GITHUB_STEP_SUMMARY
          echo "| CloudWatch | ${CLOUDWATCH_STATUS:-‚ùå} | Monitoring |" >> $GITHUB_STEP_SUMMARY

          # Network resources with cleanup details
          echo "| Network - VPC Endpoints | ${NETWORK_ENDPOINTS_STATUS:-‚ùå} | Cleaned: ${ENDPOINTS_CLEANED:-0} of ${ENDPOINTS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NAT & EIP | ${NETWORK_NAT_STATUS:-‚ùå} | Cleaned: ${NATS_CLEANED:-0} of ${NATS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Route Tables | ${NETWORK_ROUTE_STATUS:-‚ùå} | Cleaned: ${ROUTES_CLEANED:-0} of ${ROUTES_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NACLs | ${NETWORK_NACL_STATUS:-‚ùå} | Cleaned: ${NACLS_CLEANED:-0} of ${NACLS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Subnets | ${NETWORK_SUBNET_STATUS:-‚ùå} | Cleaned: ${SUBNETS_CLEANED:-0} of ${SUBNETS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - IGW | ${NETWORK_IGW_STATUS:-‚ùå} | Cleaned: ${IGW_CLEANED:-0} of ${IGW_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - VPCs | ${NETWORK_VPC_STATUS:-‚ùå} | Cleaned: ${VPCS_CLEANED:-0} of ${VPCS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Overall | ${NETWORK_STATUS:-‚ùå} | Network Stack |" >> $GITHUB_STEP_SUMMARY

          echo "| S3 State | ${S3_STATUS:-‚ùå} | Terraform State |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform Version: \`${TF_VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Region: \`${AWS_REGION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Project: \`${PROJECT_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Timestamp: \`$(date -u '+%Y-%m-%d %H:%M:%S UTC')\`" >> $GITHUB_STEP_SUMMARY
